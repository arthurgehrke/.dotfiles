#!/usr/bin/env zsh# Função para buscar interativamente com fuzzy finder usando ripgrep e abrir no Neovimexport irg() {    local file    local line    local RG_PREFIX="rg --column --line-number --no-heading --color=always --smart-case "    local INITIAL_QUERY="${*:-}"        read -r file line <<<$(        FZF_DEFAULT_COMMAND="$RG_PREFIX $(printf %q "$INITIAL_QUERY")" \            fzf --ansi \            --disabled --query "$INITIAL_QUERY" \            --color "hl:-1:underline,hl+:-1:underline:reverse" \            --header='Press ? to toggle preview / CTRL-R for ripgrep / CTRL-F for fzf' \            --bind '?:toggle-preview' \            --bind "change:reload:sleep 0.1; $RG_PREFIX {q} || true" \            --bind "ctrl-f:unbind(change,ctrl-f)+change-prompt(2. fzf> )+enable-search+rebind(ctrl-r)+transform-query(echo {q} > /tmp/rg-fzf-r; cat /tmp/rg-fzf-f)" \            --bind "ctrl-r:unbind(ctrl-r)+change-prompt(1. ripgrep> )+disable-search+reload($RG_PREFIX {q} || true)+rebind(change,ctrl-f)+transform-query(echo {q} > /tmp/rg-fzf-f; cat /tmp/rg-fzf-r)" \            --bind "start:unbind(ctrl-r)" \            --prompt '1. ripgrep> ' \            --layout reverse \            --delimiter : \            --preview-window 'up,60%,border-bottom,~2,+{2}+2/2' \            --preview 'bat --style=full --color=always --highlight-line {2} {1}' | awk -F: '{print $1, $2}'    )    if [[ -n "$file" ]]; then        nvim "$file" "+$line"    fi}autoload -U irg# Função para listar diretórios visitados recentemente com fzffunction fzf-cdr() {  local selected_dir=$(cdr -l | awk '{ print $2 }' | fzf)  if [ -n "$selected_dir" ]; then    LBUFFER+="${selected_dir}"  fi}zle -N fzf-cdr# Cria um diretório e já muda para elefunction mkcd() {    mkdir -p -- "$1" && cd -P -- "$1" || return}# Função para criar uma nova aba no iTerm2function newtabi() {    osascript \        -e 'tell application "iTerm2" to tell current window to set newWindow to (create tab with default profile)' \        -e "tell application \"iTerm2\" to tell current session of newWindow to write text \"$*\""}# Função para mudar o título de uma aba no iTerm2function titlei {    echo -ne "\033]0;"$*"\007"}# Função para executar comandos iTerm2function iterm {    local ARGS    itermCmds=("newtabi" "titlei")    cmd=$(printf "%s\n" "${itermCmds[@]}" | fzf --reverse)    echo -n "enter chosen command args (if any) - enter for no args: "    read -r ARGS    eval "$cmd" "$ARGS"}# Função para remover arquivos com confirmação interativafunction rm() (    local SOURCES    local REPLY    local ERRORMSG    if [[ "$#" -eq 0 ]]; then        echo -n "Deseja usar a força (remover forçadamente)? y/n: "        read -r REPLY        SOURCES=$(find . -maxdepth 1 | fzf --multi)        if [[ $REPLY =~ ^[Yy]$ ]]; then            echo "Removendo forçadamente..."            echo "$SOURCES" | xargs -I '{}' rm -rf {}        else            echo "$SOURCES" | xargs -I '{}' rm {}        fi        echo "Arquivos/pastas removidos."    else        ERRORMSG=$(command rm "$@" 2>&1)        if [ -n "$ERRORMSG" ]; then            echo "$ERRORMSG"            echo -n "Remoção falhou. Usar força? y/n: "            read -r REPLY            if [[ "$REPLY" =~ ^[Yy]$ ]]; then                echo "Removendo forçadamente..."                command rm -rf "$@"            fi        else            echo "Arquivo/pasta removido."        fi    fi)# Função para mudar de diretório com fuzzy finderfunction cdf() {    local dir=$(find ${1:-.} -type d 2> /dev/null | fzf --height 40% --layout=reverse --border)    [[ -n "$dir" ]] && cd "$dir" && zle reset-prompt || { echo "Nenhum diretório selecionado."; return 1; }}zle -N cdf# Definindo algumas opções padrão para o FZFexport FZF_DEFAULT_OPTS='--color=bg+:#3c3836,bg:#32302f,spinner:#fb4934,hl:#928374,fg:#ebdbb2,header:#928374,info:#8ec07c,pointer:#fb4934,marker:#fb4934,fg+:#ebdbb2,prompt:#fb4934,hl+:#fb4934'# Função para criar uma imagem bonita do código na área de transferênciafunction codepic() {    silicon --from-clipboard -l $1 -o ~/Downloads/Temp/$2.png --background '#fff0' --theme 'gruvbox'}# Função para mover arquivos com confirmação interativafunction mv() {    local SOURCES    local TARGET    local REPLY    local ERRORMSG    if [[ "$#" -eq 0 ]]; then        echo -n "Deseja usar a força (sobrescrever)? y/n: "        read -r REPLY        echo "Informe o destino: "        vared -p 'Destino: ' -c TARGET        SOURCES=$(find . -maxdepth 1 | fzf --multi)        if [[ $REPLY =~ ^[Yy]$ ]]; then            echo "Movendo com força..."            echo "$SOURCES" | xargs -I '{}' mv -f {} "$TARGET"        else            echo "$SOURCES" | xargs -I '{}' mv {} "$TARGET"        fi        echo "Arquivos/pastas movidos."    else        ERRORMSG=$(command mv "$@" 2>&1)        if [ -n "$ERRORMSG" ]; then            echo "$ERRORMSG"            echo -n "Mover falhou. Usar força? y/n: "            read -r REPLY            if [[ "$REPLY" =~ ^[Yy]$ ]]; then                echo "Movendo com força..."                command mv -f "$@"            fi        fi    fi}# Função para encontrar arquivos com fzf e abrir no editor padrãofunction fzf-find-files() {    local file=$(fzf --multi --reverse) # Obtém o arquivo pelo fzf    if [[ $file ]]; then        for prog in $(echo $file); do            $EDITOR "$prog"        done    else        echo "cancelled fzf"    fi}# Função para buscar e instalar pacotes com Homebrew usando fzffunction brewinstaller() {    local inst=$(brew search | fzf --multi --header='[brew:install]')    if [[ $inst ]]; then        for prog in $(echo $inst); do            brew install "$prog"        done    fi}# Função para instalar múltiplos pacotes selecionados via Homebrewbrewip() {    local inst=$(brew search | fzf --multi)    if [[ $inst ]]; then        for prog in $(echo $inst); do            brew install "$prog"        done    fi}# Função para atualizar pacotes Homebrew selecionadosbrewup() {    local upd=$(brew leaves | fzf --multi)    if [[ $upd ]]; then        for prog in $(echo $upd); do            brew upgrade "$prog"        done    fi}# Função para desinstalar pacotes selecionados via Homebrewbrewdp() {    local uninst=$(brew leaves | fzf --multi)    if [[ $uninst ]]; then        for prog in $(echo $uninst); do            brew uninstall "$prog"        done    fi}# Função para desinstalar pacotes via Homebrew com fzfbrew-uninstall() {    execute-fzf "brew list" "brew uninstall"}# Função para desinstalar pacotes cask via Homebrew com fzfbrew-cask-uninstall() {    execute-fzf "brew list --cask" "brew uninstall --cask"}alias bcun='brew-cask-uninstall'# Função para verificar pacotes desatualizados com Homebrewbrew-outdated() {    echo "==> Atualizando brew..."    brew update >/dev/null    echo "\n==> Pacotes e casks desatualizados"    brew outdated}# Função para atualizar pacotes e casks do Homebrewbrew-upgrade() {    echo "\n==> Atualizando pacotes"    brew upgrade    echo "\n==> Atualizando casks"    brew upgrade --cask}# Função para abrir arquivos encontrados pelo fzf no editorff() {    $EDITOR $(find * -type f | fzf --multi --reverse --preview "$(getFZFPreviewer)")}# Função para mudar para o diretório do arquivo selecionado via fzffz() {    local file=$(fzf +m -q "$1")    local dir=$(dirname "$file")    cd "$dir" && ls}# Função para encontrar diretórios com fzffd() {    local dir=$(find ${1:-.} -path '*/\.*' -prune -o -type d -print 2>/dev/null | fzf +m)    [[ $dir ]] && cd "$dir" && ls}# Função para encontrar diretórios, incluindo ocultos, com fzffdh() {    local dir=$(find ${1:-.} -type d 2>/dev/null | fzf +m)    [[ $dir ]] && cd "$dir" && ls}# Função para navegar para diretórios superiores usando fzff..() {    local declare -a dirs=()    get_parent_dirs() {        if [[ -d "$1" ]]; then            dirs+=("$1")        else            return        fi        [[ "$1" == '/' ]] && printf "%s\n" "${dirs[@]}" || get_parent_dirs "$(dirname "$1")"    }    local dir=$(get_parent_dirs "$(realpath "${1:-$PWD}")" | fzf-tmux --tac)    cd "$dir" && ls}# Função para exibir o histórico de commits do Git com fzfgc() {    if [[ $# -gt 0 ]]; then        git commit -m "$*"    else        git log --graph --color=always --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" |            fzf --ansi --no-sort --reverse --tiebreak=index --preview \                'git show --color=always {1} | delta' --preview-window=right:60%    fi}# Função para obter o ID de commits do Git com fzfcommitids() {    local commits=$(git log --color=always --pretty=oneline --abbrev-commit --reverse)    local commit=$(echo "$commits" | fzf --tac +s +m -e --ansi --reverse)    echo -n "$(echo "$commit" | sed "s/ .*//")"}# Função para listar e mudar para branches recentes do Git com fzfgbrl() {    if [[ $# -eq 0 ]]; then        local branches=$(git for-each-ref --count=30 --sort=-committerdate refs/heads/ --format="%(refname:short)")        local branch=$(echo "$branches" | fzf-tmux -d $((2 + $(wc -l <<<"$branches"))) +m)        git checkout "$(echo "$branch" | sed "s/.* //")"    else        git checkout "$@"    fi}# Função para mudar para branches do Git, incluindo remotos, com fzfgbr() {    if [[ $# -eq 0 ]]; then        local branches=$(git branch -a)        local branch=$(echo "$branches" | fzf-tmux -d $((2 + $(wc -l <<<"$branches"))) +m)        git checkout "$(echo "$branch" | sed "s/.* //" | sed "s#remotes/[^/]*/##")"    else        git checkout "$@"    fi}# Função para manipular stashes do Git com fzfstashes() {    local out q k sha    while out=$(git stash list --pretty="%C(yellow)%h %C(green)%cr %C(blue)%gs" | fzf --ansi --no-sort --query="$q" --print-query --expect=ctrl-d,ctrl-b); do        mapfile -t out <<<"$out"        q="${out[0]}"        k="${out[1]}"        sha="${out[-1]}"        sha="${sha%% *}"        [[ -z "$sha" ]] && continue        if [[ "$k" == 'ctrl-d' ]]; then            git diff "$sha"        elif [[ "$k" == 'ctrl-b' ]]; then            git stash branch "stash-$sha" "$sha"            break        else            git stash show -p "$sha"        fi    done}# Função para exibir o status do Git com fzf e abrir arquivos no editorgs() {    git rev-parse --git-dir >/dev/null 2>&1 || { echo "Você não está em um repositório Git"; return; }    local selected=$(git -c color.status=always status --short | fzf --height 50% --preview 'git diff --color=always -- {-1} | delta' --ansi --multi | cut -c4- | sed 's/.* -> //')    [[ $selected ]] && for prog in $selected; do nvim "$prog"; done}# Função para listar remotos do Git com fzfgrr() {    git remote -v | awk '{print $1 "\t" $2}' | uniq | fzf --tac --preview 'git log --oneline --graph --color=always {1} | head -200' | cut -d$'\t' -f1}# Função para escolher e mudar para commits do Git com fzfcheckout() {    local commits=$(git log --pretty=oneline --abbrev-commit --reverse)    local commit=$(echo "$commits" | fzf --tac +s +m -e)    git checkout "$(echo "$commit" | sed "s/ .*//")"}# Função para listar branches do Git com fzffbr() {    git branch -a --color=always | grep -v '/HEAD' | sort | fzf --multi --tac --preview 'git log --oneline --graph --color=always $(sed "s/^..//" <<< {})' | sed 's/^..//' | cut -d' ' -f1}# Função para listar tags do Git com fzftags() {    git tag --sort -version:refname | fzf --multi --preview 'git show --color=always {} | head -$LINES'}# Função para repetir um comando do históricohistory() {    print -z "$([ -n "$ZSH_NAME" ] && fc -l 1 || history | fzf --tac | sed 's/ *[0-9]* *//')"}# Função para buscar variáveis de ambiente com fzfvars() {    local out=$(env | fzf)    echo "$(echo $out |